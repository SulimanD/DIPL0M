# Поиск элементов с помощью Selenium WebDriver

## Поиск элементов с помощью Selenium

Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий, позволяющих искать по атрибутам
элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Для поиска Selenium предоставляет метод `find_element`,
который принимает два аргумента - тип локатора и значение локатора. Существуют следующие методы поиска элементов:

+ `find_element(By.ID, value)` - поиск по уникальному атрибуту `id` элемента. Если ваши разработчики проставляют всем
  элементам в приложении уникальный `id`, то вам повезло, и вы чаще всего будет использовать этот метод, так как он
  наиболее стабильный;
+ `find_element(By.CSS_SELECTOR, value)` - поиск элемента с помощью правил на основе CSS. Это универсальный метод
  поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если
  `find_element_by_id` вам не подходит из-за отсутствия `id` у элементов, то скорее всего вы будете использовать именно
  этот метод в ваших тестах;
+ `find_element(By.XPATH, value)` - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск
  элементов;
+ `find_element(By.NAME, value)` - поиск по атрибуту name элемента;
+ `find_element(By.TAG_NAME, value)` - поиск элемента по названию тега элемента;
+ `find_element(By.CLASS_NAME, value)` - поиск по значению атрибута class;
+ `find_element(By.LINK_TEXT, value)` - поиск ссылки на странице по полному совпадению;
+ `find_element(By.PARTIAL_LINK_TEXT, value)` - поиск ссылки на странице, если текст селектора совпадает с любой частью
  текста ссылки.

Например, мы хотим найти кнопку со значением `id="submit_button"`:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit")
```

Обратите внимание, что мы импортировали класс By, который содержит все возможные локаторы.

Если страница у вас загрузилась, но дальше ничего не происходит, вернитесь обратно в консоль, в которой вы запускали ваш
скрипт. Скорее всего, вы увидите там ошибку `NoSuchElementException`. Она будет выглядеть следующим образом:

```
selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element:
{"method":"id","selector":"submit"}
```

Ошибка очевидна: мы неправильно указали локатор — значит, кнопки с таким `id` на странице нет.

Исправим локатор, чтобы наш код проходил без ошибок:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit_button")
```

### Поиск нескольких элементов

Вы можете столкнуться с ситуацией, когда на странице будет несколько элементов, подходящих под заданные вами параметры
поиска. В этом случае WebDriver вернет вам только первый элемент, который встретит во время поиска по HTML. Если вам
нужен не первый, а второй или следующие элементы, вам нужно либо задать более точный селектор для поиска, либо
использовать методы `find_elements`, которые мы рассмотрим чуть позже.

## Работа с браузером в Selenium

Если вы уже пробовали запускать примеры скриптов, то могли заметить, что браузер не всегда закрывается после выполнения
кода. Поэтому обратите внимание на то, что необходимо явно закрывать окно браузера в нашем коде при помощи команды
`browser.quit()`. Каждый раз при открытии браузера `browser = webdriver.Chrome()` в системе создается процесс, который
останется висеть, если вы вручную закроете окно браузера. Чтобы не остаться без оперативной памяти после запуска
нескольких скриптов, всегда добавляйте к своим скриптам команду закрытия:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()

# закрываем браузер после всех манипуляций
browser.quit()
```

Важно еще пояснить разницу между двумя командами: `browser.close()` и `browser.quit()`.
Какая между ними разница, ведь на первый взгляд обе они осуществляют одно и то же?

На самом деле, `browser.close()` закрывает текущее окно браузера.
Это значит, что если ваш скрипт вызвал всплывающее окно,
или открыл что-то в новом окне или вкладке браузера, то закроется только текущее окно, а все остальные останутся висеть.
В свою очередь `browser.quit()` закрывает все окна, вкладки,
и процессы вебдрайвера, запущенные во время тестовой сессии.

Подробнее можно посмотреть
здесь:
[Difference between webdriver.Dispose(), .Close() and .Quit()](https://stackoverflow.com/questions/15067107/difference-between-webdriver-dispose-close-and-quit).

Будьте внимательны с этими методами и, в общем случае, всегда используйте `browser.quit()`.

Но что будет, если скрипт не дойдет до выполнения этого финального шага, а упадет с ошибкой где-то раньше?

Для того чтобы гарантировать закрытие, даже если произошла ошибка в предыдущих строках, проще всего использовать
конструкцию `try/finally`:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"

try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()

finally:
    # закрываем браузер после всех манипуляций
    browser.quit()
```

## Поиск всех необходимых элементов с помощью find_elements

Мы уже упоминали, что метод find_element возвращает только первый из всех элементов, которые подходят под условия
поиска. Иногда возникает ситуация, когда у нас есть несколько одинаковых по сути объектов на странице, например, иконки
товаров в корзине интернет-магазина. В тесте нам нужно проверить, что отображаются все выбранные для покупки товары. Для
этого существует метод `find_elements`, которые в отличие от `find_element` вернёт список всех найденных элементов по
заданному условию. Проверив длину списка, мы можем удостовериться, что в корзине отобразилось правильное количество
товаров. Пример кода (код приведен только для примера, сайта fake-shop.com скорее всего не существует):

```python
# подготовка для теста
# открываем страницу первого товара
# данный сайт не существует, этот код приведен только для примера
browser.get("https://fake-shop.com/book1.html")

# добавляем товар в корзину
add_button = browser.find_element(By.CSS_SELECTOR, ".add")
add_button.click()

# открываем страницу второго товара
browser.get("https://fake-shop.com/book2.html")

# добавляем товар в корзину
add_button = browser.find_element(By.CSS_SELECTOR, ".add")
add_button.click()

# тестовый сценарий
# открываем корзину
browser.get("https://fake-shop.com/basket.html")

# ищем все добавленные товары
goods = browser.find_elements(By.CSS_SELECTOR, ".good")

# проверяем, что количество товаров равно 2
assert len(goods) == 2
```

**!Важно.**
Обратите внимание на важную разницу в результатах, которые возвращают методы `find_element` и `find_elements`.
Если первый метод не смог найти элемент на странице, то он вызовет ошибку `NoSuchElementException`, которая прервёт
выполнение вашего кода.
Второй же метод всегда возвращает валидный результат: если ничего не было найдено, то он вернёт пустой
список и ваша программа перейдет к выполнению следующего шага в коде.

## Уникальность селекторов: часть 1

Как отмечалось ранее, идеальный селектор — это тот, который идентифицирует один конкретный элемент на странице.
Уникальные селекторы повышают стабильность тестирования и снижают зависимость от изменений макета страницы. Разработчики
часто вносят незначительные изменения в страницы, и мы хотим свести к минимуму необходимость постоянной корректировки
наших тестов.

Важно отметить, что эффективные тесты сосредоточены на тестировании небольших отдельных функциональных единиц. Простые
тесты, предназначенные для определенного сценария, предпочтительнее больших тестов, которые пытаются охватить сразу
несколько сценариев. Простые тесты позволяют быстро локализовать ошибки и могут выявить несколько проблем одновременно.
Напротив, большой автотест завершается при первой обнаруженной ошибке.

Рассмотрим следующий пример: у нас есть форма регистрации, в которой есть обязательные и необязательные поля для
заполнения. Нужно проверить, что можно успешно зарегистрироваться на сайте.

**Сценарий плохого автотеста:**

1

+ Открыть страницу с формой
+ Заполнить все поля
+ Нажать кнопку "Регистрация"
+ Проверить, что есть сообщение об успешной регистрации

**Лучше разбить предыдущий тест на набор более простых автотестов:**

1

+ Открыть страницу с формой
+ Заполнить только обязательные поля
+ Нажать кнопку "Регистрация"
+ Проверить, что есть сообщение об успешной регистрации

2

+ Открыть страницу с формой
+ Заполнить все обязательные поля
+ Заполнить все необязательные поля
+ Нажать кнопку "Регистрация"
+ Проверить, что есть сообщение об успешной регистрации

3

+ Открыть страницу с формой
+ Заполнить только необязательные поля
+ Проверить, что кнопка "Регистрация" неактивна

## Уникальность селекторов: часть 2

Попробуем реализовать один из автотестов из предыдущего шага. Вам
дана [страница](http://suninjuly.github.io/registration1.html) с формой регистрации. Проверьте, что
можно зарегистрироваться на сайте, заполнив только обязательные поля, отмеченные символом `*`: First name, last name,
email. Текст для полей может быть любым. Успешность регистрации проверяется сравнением ожидаемого текста "
Congratulations! You have successfully registered!" с текстом на странице, которая открывается после регистрации. Для
сравнения воспользуемся стандартной конструкцией assert из языка Python.

Ниже дан шаблон кода, который вам нужно использовать для своего теста. Не забывайте, что селекторы должны быть
уникальными.

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

try:
    link = "http://suninjuly.github.io/registration1.html"
    browser = webdriver.Chrome()
    browser.get(link)

    # Ваш код, который заполняет обязательные поля
    ...

    # Отправляем заполненную форму
    button = browser.find_element(By.CSS_SELECTOR, "button.btn")
    button.click()

    # Проверяем, что смогли зарегистрироваться
    # ждем загрузки страницы
    time.sleep(1)

    # находим элемент, содержащий текст
    welcome_text_elt = browser.find_element(By.TAG_NAME, "h1")
    # записываем в переменную welcome_text текст из элемента welcome_text_elt
    welcome_text = welcome_text_elt.text

    # с помощью assert проверяем, что ожидаемый текст совпадает с текстом на странице сайта
    assert "Congratulations! You have successfully registered!" == welcome_text

finally:
    # ожидание чтобы визуально оценить результаты прохождения скрипта
    time.sleep(10)
    # закрываем браузер после всех манипуляций
    browser.quit()
```

Углубимся немного в использовании конструкции `assert` из данного примера. Если результат проверки "Поздравляем! Вы
успешно зарегистрировались!" == welcome_text вернет значение `False`, то далее выполнится код **assert False.**
Он бросит исключение `AssertionError` и номер строки, в которой произошла ошибка.
Если код написан правильно и работал ранее, то
такой результат равносилен тому, что наш автотест обнаружил баг в тестируемом веб-приложении.
Если результат проверки вернет `True`, то выполнится выражение **assert True**.
В этом случае код завершится без ошибок — тест прошел успешно.

Ознакомьтесь дополнительно с ассертом самостоятельно:
[Инструкция assert / для начинающих](https://pythonru.com/uroki/35-instrukcija-assert-dlja-nachinajushhih)

### Замечание

В этом примере мы использовали метод `time.sleep(1)`, чтобы дождаться загрузки следующей страницы, прежде чем выполнять
проверки. Если вы будете запускать код без этого метода, ваш код может внезапно упасть, хотя проходил ранее. Без
использования такой паузы WebDriver может перейти к поиску тега `h1` слишком рано, когда новая страница еще не
загрузилась. В таком случаем будем видеть в терминале ошибку:

```
NoSuchElementException... Unable to locate element: {"method":"tag name","selector":"h1"}
```

Метод `time.sleep(1)` говорит Python подождать 1 секунду, прежде чем выполнять следующую строчку кода.
Если вы всё равно видите эту ошибку, просто увеличьте количество секунд ожидания.

Разработка UI автотестов может быть сложной задачей, и одной из самых больших проблем является
своевременный поиск элементов. Скорость загрузки страниц может сильно различаться из-за изменения скорости сетевого
подключения и неравномерной загрузки сервера. Еще одним фактором, влияющим на стабильность теста, является асинхронное
выполнение кода JavaScript. Хотя это может быть незаметно на простых страницах, страницы со многими функциями могут
сделать время агрузки элементов страницы непредсказуемым.
Во избежание сбоев тестов, вызванных факторами, не зависящими от нас,
рекомендуется организовывать тесты таким образом, чтобы смягчить влияние нестабильной скорости интернета или других
внешних факторов.

Решать эту проблему с помощью `time.sleep()` считается плохой практикой, так как заранее трудно указать нужное время
ожидания. Если выставить слишком большое время ожидания, то тесты будут идти неоправданно долго. Далее мы
рассмотрим более красивые и эффективные способы решения этой проблемы, а пока будем использовать `time.sleep()` из-за
его простоты и наглядности.
