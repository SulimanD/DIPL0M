# Что такое Page Object?

В этой части курса мы будем использовать принципы объектно-ориентированного программирования и вам не помешает освежить в
памяти основные принципы ООП по ссылкам на дополнительные материалы.

## Code Style

В сообществе программистов существует широко распространенное соглашение, известное как «стиль кода» (Code
Style). Стиль кода
охватывает все аспекты, не связанные с функциональностью самого кода, такие как форматирование, имена переменных и
функций, и другие подобные соображения. Python, в частности, хвалят за его удобочитаемость, но даже этот язык может
превратиться в нечитаемый беспорядок, если его не поддерживать должным образом. Нечитаемый код представляет опасность,
поскольку становится трудным для понимания и может вызвать путаницу в будущем как у вас, так и у других. С другой
стороны, хорошо написанный код предлагает множество преимуществ, включая экономию времени при исправлении ошибок, более
плавную адаптацию новых членов команды и более эффективную разработку кода в целом. Поэтому поддержание читабельности
кода всегда должно быть главным приоритетом.

В предыдущих частях мы кратко обсуждали эту тему, а теперь более уместно углубиться в неё более подробно.

### Отступы

Отступы являются важным аспектом синтаксиса Python, поскольку они означают вложенность блоков, таких как тело условного
оператора или цикла. Важно отметить, что на следующих шагах должны поддерживаться правильные отступы для всех функций
внутри класса.

```python
# Тест вне класса, отступ не нужен.
def test_equal(a, b):
    assert a == b, f'Expected {a=} to be equal {b=}'


class TestInteractionsPage:
    """Class represents Interactions tab.
    Sortable
    Selectable,
    Resizable,
    Droppable
    """

    # Класс внутри класса. Необходим отступ, чтобы показать вложенность.
    class TestSortablePage:
        """Class represents Sortable tab tests."""
        sortable_page_link = 'https://demoqa.com/sortable'

        # Тест внутри вложенного класса. Необходим отступ.
        def test_order_of_list_can_be_changed(self, driver):
            """Test order of list can be changed."""
            sortable_page = SortablePage(driver, self.sortable_page_link)
            sortable_page.open()
            order_of_list_before = sortable_page.get_items_of_list()
            sortable_page.change_list_order()
            order_of_list_after = sortable_page.get_items_of_list()
            assert order_of_list_before != order_of_list_after, \
            'Expected order of list to be different.' \
            f'Order before: {order_of_list_before}' \
            f'Order after: {order_of_list_after}'

```

### Имена переменных и функций

Именование — важнейший элемент написания читаемого кода. Будь то объявление переменных, определение функций или
присвоение имен классам, важно убедиться, что назначенные имена имеют смысл и точно отражают суть соответствующих
объектов. Избегайте использования однобуквенных или расплывчатых имен, таких как var1, x, y, my_function, class2 и т. д.
Цель состоит в том, чтобы создать код, который говорит сам за себя и не требует дополнительных объяснений. Если вы
обнаружите, что хотите написать поясняющий комментарий, это хорошая возможность реорганизовать код и устранить
необходимость в комментариях за счет улучшения соглашений об именах.

Как правило, компании имеют свои внутренние соглашения относительно именования переменных. Однако общие отраслевые
правила именования переменных относительно одинаковы в разных организациях.

#### Функции и методы пишутся с помощью snake_case:

```python
def test_revertable_draggable_will_return_to_current_position_after_dragging(self, driver):
    pass
```

```python
def switch_to_frame(self, frame_locator, timeout=5):
    pass
```

#### Классы пишут с помощью CamelCase:

```python
class AccordianPage(BasePage):
    pass
```

```python
class TestAccordianPage:
    pass
```

Константы пишут в стиле UPPERCASE:

```python
NO_ERRORS_TEXT = 'No errors'
```

#### Максимальная простота кода

Распространенные принципы DRY ([Don't repeat yourself](https://en.wikipedia.org/wiki/Don't_repeat_yourself)) и
KISS ([Keep itsimple, stupid](https://en.wikipedia.org/wiki/KISS_principle)).

+ Старайтесь писать как можно более простой код, избегая ненужной сложности.
+ Сведите к минимуму использование сложных конструкций, таких как лямбда-выражения, карты и другие сложные методы, если
  только они не являются действительно необходимыми.
+ Всякий раз, когда у вас есть возможность заменить часть кода более простой альтернативой, сделайте это.
+ Подчеркните линейную структуру кода, так как ее легче понять и следовать.
+ Избегайте чрезмерной вложенности блоков кода, так как это может затруднить чтение кода.
+ По возможности избегайте дублирования логики. Если вы заметили повторяющиеся шаблоны, выделите эту логику в отдельный
  компонент или функцию, чтобы избежать повторения.
+ По возможности предпочтите явный код неявному коду. Лучше иметь четкий и понятный код, чем полагаться на скрытое или
  магическое поведение.

## Code Style в автотестах

Важные принципы написания автотестов:

+ Стремитесь поддерживать высокий уровень линейности в своем тестовом коде, сводя к минимуму использование ветвлений и
  циклов в тестовых примерах. Если вы обнаружите, что вам нужно ввести условные операторы (например, оператор «if») в
  свои тесты, рассмотрите возможность разделения теста на два отдельных теста или внесите изменение тестовой среды,
  чтобы исключить необходимость ветвления.

    + Уменьшая число ветвлений и сохраняя линейность тестового кода, вы можете улучшить
      читабельность и удобство сопровождения ваших тестов, упрощая их понимание и устранение неполадок.

+ Сведите к минимуму использование зависимых тестов, основанных на определенном порядке выполнения. По мере расширения
  набора тестов вы можете захотеть запускать тесты одновременно в нескольких потоках, что усложняется при использовании
  зависимых тестов. Кроме того, зависимые тесты могут привести к проблемам с надежностью.

    + Избегая зависимостей между тестами, вы обеспечиваете большее распараллеливание и повысите общую надежность набора
      тестов. Каждый тест должен быть автономным и независимым, что обеспечивает гибкость выполнения и более точные
      результаты тестирования.
      Подробнее: [...почему зависимости между тестами это плохо?](http://barancev.github.io/test-deps-are-evil/)

+ Стремитесь сделать ваши тесты самодостаточными и независимыми от конкретного контента. Вместо этого сосредоточьтесь на
  подготовке необходимых данных в самом тесте и обеспечьте надлежащую очистку после завершения теста. Рекомендуется
  использовать чистые браузеры и создавать новые учетные записи пользователей для повышения воспроизводимости.

    + Генерируя необходимые данные и управляя тестовой средой в тестовом коде, вы уменьшаете зависимость от внешних
      факторов, делая ваши тесты более надежными и воспроизводимыми при различных исполнениях. Такой подход обеспечивает
      лучшую изоляцию и повышает общую стабильность набора тестов.

+ Стремитесь к линейному потоку в своих проверках, избегая использования ветвей и циклов в функциях `assert`.
  Важно, чтобы логика проверок была простой и линейной. Такой подход упрощает анализ ошибок и делает сопровождение
  тестирования более экономичным.

    + Придерживаясь линейных проверок, вы гарантируете, что каждое утверждение следует четкому пути без ненужных
      ветвлений или циклов. Это способствует удобочитаемости, ремонтопригодности и упрощению устранения неполадок при
      возникновении проблем.

+ Именуйте проверки в одинаковом стиле, чтобы по первому взгляду можно было понять, что это именно проверка.

+ Названия тестов должны соответствовать единому стилю и эффективно отражать различия между похожими сценариями. Подобно
  добавлению имен к тест-кейсам в тестовой документации, вы можете использовать аналогичные подходы для именования
  своих тестов.

    + Важно выбрать описательные и осмысленные имена для ваших тестов, подчеркивая конкретные различия или тестируемые
      аспекты. Следуя единому стилю именования, вы повышаете удобочитаемость и понятность своего набора тестов. Кроме
      того, понятные и информативные названия тестов облегчают эффективную коммуникацию и сотрудничество между членами
      команды.

+ Вместо того, чтобы дублировать идентичные тесты с небольшими различиями в содержании, например, в языке интерфейса,
  рекомендуется их параметризовать. Параметризация позволяет повторно использовать одну и ту же тестовую логику,
  предоставляя разные входные значения.

    + Параметризируя тесты, вы можете определить один тестовый пример и указать различное содержимое в качестве
      параметров.
      Такой подход устраняет дублирование кода, повышает удобство сопровождения и упрощает процесс добавления новых
      тест-кейсов с аналогичными характеристиками.

    + Параметризация обеспечивает эффективное управление тестированием и помогает обеспечить охват всех соответствующих
      сценариев без ненужного дублирования тестового кода.

+ Рекомендуется писать тесты, которые являются атомарными и неделимыми, то есть каждый тест фокусируется на определенной
  функциональности или сценарии. Вместо того, чтобы создавать один большой тест, который проверяет сразу несколько
  аспектов, лучше разбить его на более мелкие, более целенаправленные тесты. Такой подход позволяет лучше локализовать
  проблему и упрощает устранение неполадок при их возникновении.

    + Сохраняя тесты атомарными, вы можете точно определить местонахождение сбоев и определить конкретную
      функциональность, вызывающую проблему. Это также способствует модульности и возможности повторного использования,
      поскольку тесты меньшего размера можно комбинировать или повторно использовать в разных сценариях.

    + Написание небольших целенаправленных тестов повышает удобство сопровождения и удобочитаемость тестов. Это
      позволяет быстрее выявлять и решать проблемы, повышая общую эффективность процесса тестирования.

Рекомендуется ознакомится с Code Style для написания автотестов из дополнительных материалов.

## Подготовка окружения

Целью этого дипломного проекта является обучение основам автоматизированного тестирования UI и, чтобы приблизиться к
достижению этой цели, вы должны практиковаться.

Мы создадим отдельный публичный репозиторий и будем постепенно добавлять и изменять код автотестов, чтобы сохранить
историю коммитов и приблизиться к промышленной разработке.

Начнём:

1. Создайте отдельный публичный репозиторий с осмысленным названием на GitHub.
2. Добавьте в свой репозиторий файлы `README.md` и Python `.gitignore`.
3. Склонируйте его к себе на локальную машину.
4. Добавьте туда файл `conftest.py` из предыдущего модуля. Убедитесь дополнительно, что там есть параметр для задания
   языка интерфейса, по умолчанию равный `en`.
5. Убедитесь что ни во вложенных папках, ни во внешних папках нет других файлов `conftest.py`.
6. Добавьте в репозиторий файл `requirements.txt` из предыдущего модуля.
7. Создайте пустой файл `__init__.py`, чтобы работали относительные импорты.
8. Создайте файл `test_main_page.py` и добавьте в него тест из предыдущего модуля:

```python
def test_guest_can_go_to_login_page(browser):
    link = "http://selenium1py.pythonanywhere.com/"
    browser.get(link)
    login_link = browser.find_element(By.CSS_SELECTOR, "#login_link")
    login_link.click()
```

9. Создайте новое виртуальное окружение для этого проекта и убедитесь, что в нем установлены все зависимости из
   файла `requirements.txt`
10. Убедитесь, что тест работает, с помощью следующей команды: `pytest -v --tb=line --language=en test_main_page.py`.
11. Добавьте в `README.md` небольшое описание тестового проекта.
12. Зафиксируйте изменения коммитом с осмысленным сообщением.

## Что такое Page Object Model?

Page Object Model (Page Object) — это широко используемый шаблон программирования в автоматизации тестирования,
особенно для тестирования веб-продуктов. Он служит стандартным подходом и предлагает удобный способ структурирования
кода, облегчая его обслуживание, модификацию и удобство использования.

Фундаментальная концепция модели Page Object Model заключается в представлении каждой веб-страницы приложения в виде
объекта класса. Взаимодействие со страницей можно описать с помощью методов внутри класса. В идеале тесты, использующие
Page Objects, должны быть сосредоточены на бизнес-логике тестового сценария, абстрагируя методы Selenium для
взаимодействия браузера и страницы. Такой подход упрощает обслуживание, поскольку изменения макета страницы не потребуют
модификации связанных тестов. Вместо этого необходимо обновить только класс, представляющий страницу.

К объектной модели страницы применяются те же принципы разработки кода: улучшение читаемости кода и инкапсуляция деталей
в абстрактные методы. Тесты должны быть написаны просто и понятно, с выделением повторяющихся сегментов кода в отдельные
функции. Внутри Page Object мы отличаем логику действий, таких как аутентификация пользователя, от конкретных деталей
реализации (например, поиск поля электронной почты, ввод данных, поиск поля пароля, ввод данных, расположение кнопки и
т. д.).

Рассмотрим такой простой тест-кейс:

1. Открыть главную страницу
2. Перейти на страницу логина

Ожидаемый результат:

> Открыта страница логина

Давайте посмотрим на кода теста, который реализует первую часть этого теста:

> test_main_page.py:

```python
link = "http://selenium1py.pythonanywhere.com/"


def test_guest_can_go_to_login_page(browser):
    browser.get(link)
    login_link = browser.find_element(By.CSS_SELECTOR, "#login_link")
    login_link.click()
```

Что здесь происходит?

Открывается ссылка, находится элемент с определенным селектором и производится клик на этот элемент.

Что мы на самом деле имеем в виду?

Мы хотим открыть страницу логина. Давайте выделим это действие в отдельную функцию с понятным названием, пока все в том
же файле

> test_main_page.py:

```python
def go_to_login_page(browser):
    login_link = browser.find_element(By.CSS_SELECTOR, "#login_link")
    login_link.click()
```

и наш тест упрощается:

```python
def test_guest_can_go_to_login_page(browser):
    browser.get(link)
    go_to_login_page(browser)
```

При написании последующих тестов, требующих перехода на страницу входа с главной страницы, нет необходимости дублировать
или переписывать код. Вместо этого мы можем повторно использовать ранее написанный метод, гарантируя возможность
повторного использования кода и уменьшая избыточность.

## Почему именно Page Object?

Хотя можно хранить всю тестовую логику в одном файле, таком как «steps.py», этот подход может стать проблематичным по
мере увеличения размера веб-продукта и сложности его состояний и переходов. Файл может стать слишком большим, что
затруднит поиск определенных методов. Кроме того, бывают случаи, когда один и тот же метод может иметь разные реализации
на разных страницах. Например, в нашем интернет-магазине функция «добавить в корзину» доступна как со страницы каталога,
так и со страницы отдельного продукта.

Чтобы улучшить организацию и удобство сопровождения, полезно сгруппировать методы, которые логически связаны с
конкретной веб-страницей, в выделенный класс в нашем коде. Эта концепция приводит к термину Page Object, который
относится к абстрактному объекту, инкапсулирующему методы для взаимодействия с конкретной веб-страницей.

Важно! Обычно методы у Page Object бывают двух типов: сделать что-то и проверить что-то.

Рассмотрим [страницу товара](http://selenium1py.pythonanywhere.com/en-gb/catalogue/the-shellcoders-handbook_209/) в
интернет магазине.

Какие могут быть методы у Page Object, ассоциированного с такой страницей?

Запишем основные сценарии:

+ добавить в корзину;
+ проверить, что есть сообщение об успешном добавлении в корзину;
+ перейти к написанию отзыва;
+ проверить, что есть название, цена, описание товара;
+ вернуться на главную.

Стоит отметить, что все утверждения также реализованы в виде отдельных методов. В самом тестовом примере нет
вспомогательных ключевых слов, таких как «assert», а скорее описательное представление шагов, аналогичное нашей
тестовой документации.

Тесты будут выглядеть примерно так:

```python
def test_add_to_cart(browser):
    product_page = ProductPage(browser, url='')  # инициализируем объект Page Object
    product_page.open()  # открываем страницу в браузере
    product_page.should_be_add_to_cart_button()  # проверяем что есть кнопка добавления в корзину
    product_page.add_product_to_cart()  # жмем кнопку добавить в корзину 
    product_page.should_be_success_message()  # проверяем что есть сообщение с нужным текстом

```
