# Улучшаем дизайн тестов

Вы уже знаете практически всю теорию о применении Page Object Model и далее будет много заданий на самостоятельное
выполнение. Вы будете самостоятельно их делать и проверять себя. Это сильно увеличит эффективность усвоения
теоретических знаний и у вас появится проект, который можно будет продемонстрировать.

## Задание: добавление в корзину со страницы товара

Представим вам поручили автоматизировать следующий сценарий:

1. Открыть страницу `http://selenium1py.pythonanywhere.com/catalogue/the-shellcoders-handbook_209/?promo=newYear`.
2. Нажать на кнопку "Добавить товар".
3. Решить уравнение и получить скидку, ввести ответ. Для этого использовав метод `solve_quiz_and_get_code()`, который
   вам отдали уже реализованный.

Ожидаемый результат:

1. Получение сообщения, что товар добавлен в корзину. Название товара в сообщении соответствует добавленному товару в
   корзину.
2. Сообщение со стоимостью корзины, стоимость которой соответствует стоимости добавленного товара.

Тест нужно написать, используя паттерн Page Object. Для этого вам нужно:

1. Добавить новый файл для тест-кейсов, связанных со страницей товара. Например `test_product_page.py`.
2. Создать класс для страницы товара. Опишите его в файле `product_page.py` в директории `pages`.
3. Реализовать метод для добавления в корзину.
4. Реализовать методы-проверки.
5. Добавить локаторы к элементам страницы в отдельном классе файла `locators.py`.
6. Реализовать сам тест-кейс. Назовите тест `test_guest_can_add_product_to_basket`.

Хорошей практикой является создание новой ветки, отходящей от основной, в которой уже будет реализован новый функционал.
Так же рекомендуется сперва создавать структуру, а затем уже переходить к реализации. Например, сперва создаются пустые
файлы и прописываются импорты, затем описываются необходимые локаторы, после чего уже можно переходить к созданию
объекта страницы и методы-проверки, и только в самом конце писать тесты. Но вы можете выполнять шаги с любого пункта.

```python
from selenium.common.exceptions import NoAlertPresentException


def solve_quiz_and_get_code(self):
    alert = self.browser.switch_to.alert
    x = alert.text.split()[2]
    answer = str(math.log(abs((12 * math.sin(float(x))))))
    alert.send_keys(answer)
    alert.accept()
    try:
        alert = self.browser.switch_to.alert
        alert_text = alert.text
        print(f'Code: {alert_text}')
        alert.accept()
    except NoAlertPresentException:
        print('No second alert present')

```

Напомню, чтобы видеть результаты работы функции `print()` необходимо запускать Pytest с флагом `-s`.

## Задание: независимость от данных

Для эффективных автотестов крайне важно минимизировать зависимости от конкретных данных. Жесткие проверки объектов,
уникальных для конкретного экземпляра, настоятельно не рекомендуются. Почему? Что ж, данные имеют свойство часто
меняться, что потребует постоянных фиксов автотестов. Более того, такой подход затрудняет повторное использование
кода. Например, если мы собираемся запустить тест для нескольких продуктов, нам потребуется создать множество проверок,
по одной для каждого продукта. В конечном итоге такая практика снижает качество продукта, поскольку эти тесты охватывают
лишь ограниченное количество страниц.

Общая рекомендация состоит в том, чтобы убедиться, что ваши тесты не зависят от факторов, находящихся вне вашего
контроля. Сюда входят данные, хранящиеся в базах данных или сторонних службах, используемых вашим приложением.
Желательно избегать проверки конкретных данных, если у вас нет специально подготовленной тестовой базы данных, которая
инициализируется перед каждым запуском теста, или если вы можете добавить необходимые данные непосредственно в базу
данных или через API приложения. Осуществляя контроль над тестовой средой и данными, вы можете поддерживать более
надежные и воспроизводимые тесты.

Запустите тест, который мы написали на предыдущем этапе разработки, со
ссылкой: http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=newYear2019.

Если вы на прошлом шаге проверяли конкретное название товара, то ваш тест упадёт с ошибкой, так как теперь был добавлен
другой товар. Если тест прошел успешно, то вы написали тест независимый от контекста и правильно сделали.

Чтобы тест был независимым от контента:

* Измените методы проверки так, чтобы они принимали название товара и цену товара.
* Сделайте метод, который берёт из элемента название товара и возвращает его.
* Сделайте такой же метод для цены.
* Проверьте, что название товара в сообщении совпадает с заголовком товара.

Вот несколько основных советов, как добиться независимости тестов:

1. Используйте тестовые данные: вместо того, чтобы полагаться на конкретные данные, существующие в определенном
   контексте, инициализируйте тестовые данные в самом тесте. Это гарантирует, что тест может выполняться с собственным
   набором данных независимо от контекста.

2. Избегайте "хардкодинга" значений: вместо "хардкодинга" конкретных значений или идентификаторов используйте
   переменные или константы в тестовом коде. Это обеспечивает гибкость при изменении значений без изменения логики
   тестирования.

3. Моделирование внешних зависимостей: если ваши тесты зависят от внешних систем или служб, рассмотрите возможность
   использования фиктивных (mock) фреймворков или методов для имитации этих зависимостей. Таким образом, ваши тесты
   могут выполняться независимо, не полагаясь на доступность или поведение внешних компонентов.

4. Изолируйте тестовые наборы: убедитесь, что каждый тестовый набор является автономным и не зависит от выполнения или
   результатов других тестовых наборов. Избегайте зависимостей между тестами.

5. Используйте методы setup и teardown: используйте методы настройки и очистки срезы, предоставляемые средами
   тестирования, для подготовки необходимой тестовой среды и очистки после теста. Это гарантирует, что каждый тест
   начинается с известного состояния и заканчивается приводя систему в исходное состояние.

6. Инкапсулируйте тестовую логику. Организуйте тестовый код в повторно используемые функции или классы, которые
   инкапсулируют тестовую логику. Это повышает читаемость, поддерживаемость и возможность повторного использования
   ваших тестов.

7. Избегайте зависимостей от внешних файлов конфигурации: если ваши тесты полагаются на файлы конфигурации, рассмотрите
   возможность предоставления специфичных для теста конфигураций в самом тестовом коде или с использованием методов
   имитации конфигурации.

## Задание: независимость контента, ищем баг

Теперь мы будем искать самый настоящий баг у нашего интерент-магазина.

Итак, вводная: была запущено несколько промо-акций, одна из которых приводит к появлению дефекта. Промо-акция включается
путем добавления параметра `?promo=offerN` к ссылке на товар.

На не придется писать отдельные тесты для каждой ссылки на промо-акцию, чтобы проверить её работоспособность, мы будем
использовать параметризацию. Вам нужно определить при каком значении параметра акции тест будет падать. Для этого мы
должны обнаружить проблемный URL, на котором возникает ошибка. Значение `N` у параметра `?promo=offerN` изменяется от 0
до 9.

Параметризация используется для запуска теста с разными входными данными. Вот пример, как вы можете использовать
декоратор параметризации:

```python
@pytest.mark.parametrize('link', ["http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer0",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer1",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer2",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer3",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer4",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer5",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer6",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer7",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer8",
                                  "http://selenium1py.pythonanywhere.com/catalogue/coders-at-work_207/?promo=offer9"])
def test_guest_can_add_product_to_basket(browser, link):
    # ваша реализация теста

```

Скажем, что после обнаружения бага, вам сказал, что фиксить баг в этом спринте вы не будете. Вам необходимо отметить
тест, как ожидаемо падающий, использовав xfail. Мы уже говорили, как использовать эту фичу, вы можете освежить знания в
памяти [Skip/xfail with parametrize](https://pytest.org/en/stable/how-to/skipping.html#skip-xfail-with-parametrize).

Ваша задача:

1. Параметризовать тест.
2. Обнаружить дефект.
3. Пометить тест с дефектом, как ожидаемо падающий.
4. Зафиксировать изменения коммитом с осмысленным сообщением.

## Отрицательные проверки: как проверить отсутствие элемента

Иногда при создании автотестов возникают ситуации, когда нам нужно проверить не только наличие элемента на странице, но
и его отсутствие. Здесь стоит разделить две важные особенности:

1. Элемент может быть на странице (но не должен). Например, такое часто касается различных кнопок, которые появляются
   только при выполнении определённых условий. Примером для нашего интернет-магазина может быть проверка отображения
   сообщения об успешном добавлении товара в корзину при открытии корзины. Если мы будем осуществлять поиск элемента при
   негативной проверке без ожидания, то рискуем получить проходящий успешно тест и пропустить баг, если сообщение таки
   отображается, но с небольшой задержкой.
2. Элемент отображается на странице и должен исчезнуть через определённое время или в результате действий пользователя.
   Это может быть исчезновение прогрессбара или изображения товара при отводе курсора от его изображения.

### Почему нужно писать такие проверки с осторожностью?

Во-первых, тестам всегда придётся ждать обнаружения элемента, чтобы убедиться, что элемент действительно отсутствует или
появляется. Если мы используем нашу написанную функцию `is_element_present()`, то тест с такой проверкой будет ждать
полные и честные 5 секунд:

```python
def should_not_be_success_message(self):
    assert not self.is_element_present(*ProductPageLocators.SUCCESS_MESSAGE), \
    'Success message is presented'

```

Это довольно продолжительное время для позитивного сценария и стоит подобрать для этого теста индивидуальное время путём
проб и ошибок. А для этих целей оправдано использование явных ожиданий.

Во-вторых, негативные тесты часто дают ложноположительные результаты, если селектор элемента устарел. Элемента с таким
селектором на странице нет, а сообщение отображается. Тест при этом выдаст зелёный ответ, что все в порядке. Это плохо!

Поэтому на каждый негативный тест вы должны написать позитивный тест. В одном тесте проверяете, что элемента нет, в
соседнем, что элемент есть.

Про распространённые ошибки составления UI-автотестов вы можете прочитать в
статье [UI-автотесты: как делать не стоит](https://habr.com/ru/companies/badoo/articles/419419/).

### Как же тогда реализовывать такие проверки?

Почти всегда вам придётся ориентироваться в конкретной ситуации по разному, но общая рекомендация - использовать явные
ожидания. Хорошей практикой будет придерживаться исключительно явных ожиданий в рамках проекта и не использовать
неявные.

Добавим в BasePage абстрактный метод, который проверяет, что элемент не появляется на странице в течение заданного
времени:

```python
def is_not_element_present(self, how, what, timeout=4):
    try:
        WebDriverWait(self.browser, timeout).until(EC.presence_of_element_located((how, what)))
    except TimeoutException:
        return True
    return False

```

Использование данного метода для страницы товара будет следующим:

```python
def should_not_be_success_message(self):
    assert self.is_not_element_present(*ProductPageLocators.SUCCESS_MESSAGE), \
    'Success message is presented, but should not be'

```

Если же мы хотим проверить, что какой-то элемент исчезает, то следует воспользоваться явным ожиданием вместе с функцией
`until_not()`, в зависимости от ожидаемого результата:

```python
def is_disappeared(self, how, what, timeout=1):
    try:
        WebDriverWait(self.browser, timeout).until_not(EC.presence_of_element_located((how, what)))
    except TimeoutException:
        return False
    return True

```

Напишите самостоятельно метод-проверку на исчезновение для класса страницы товара
аналогично `should_not_be_success_message()`.

Обратите внимание на разницу между методами `is_not_element_present()` и `is_disappeared()`.

Поскольку к проектированию таких тестов необходимо относиться очень аккуратно и писать дополнительные проверки, то
рекомендуется их избегать без явной необходимости.

## Задание: отрицательные проверки

Добавьте к себе в проект функции из предыдущего шага и реализуйте несколько простых тестов:

1. test_guest_cant_see_success_message_after_adding_product_to_basket:

* Открыть страницу товара
* Добавить товар в корзину
* Проверить, что нет сообщения об успехе с помощью `is_not_element_present`


2. test_guest_cant_see_success_message:

* Открыть страницу товара
* Проверить, что нет сообщения об успехе с помощью `is_not_element_present`


3. test_message_disappeared_after_adding_product_to_basket:

* Открыть страницу товара
* Добавить товар в корзину
* Проверить, что нет сообщения об успехе с помощью `is_disappeared`

Пометьте тесты, которые упали как XFail.

Не забудьте зафиксировать изменения с осмысленным сообщением коммита и запушить в свой репозиторий.

## Плюсы наследования: магия ООП

Рассмотрим один аспект парадигмы ООП, который мы до сих пор немного использовали: механизм наследования.

Мы уже его использовали, когда выделили базовый класс для наших проверок BasePage, а от него уже наследовали остальные
объекты страниц: LoginPage, MainPage. Сейчас в нашем классе BasePage базовые технические детали - поиск элементов, метод
для открытия страницы и вспомогательные методы. Но мы можем в него добавить и методы общих для всех страниц.

Важным моментом будет отделение общего от частного. Таким образом, в элемент базовой страницы должно попасть
исключительно общее для всех страниц.

Используя такой подход мы уменьшаем количество дублируемого кода и упрощаем поддержку кода.

## Плюсы наследования: пример

Вы наверное уже давно заметили, что ссылка на страницу логина присутствует на каждой странице. Если мы хотим добавить
тест `test_guest_can_go_to_login_page`, то для избежания дублирования следует перенести соответствующие методы в класс
BasePage.

В файле `locators.py` создаем новый класс BasePageLocators:

```python
class BasePageLocators():
    LOGIN_LINK = (By.CSS_SELECTOR, '#login_link')
    LOGIN_LINK_INVALID = (By.CSS_SELECTOR, '#login_link_invalid')

```

Переносим методы в `base_page.py`:

```python
from .locators import BasePageLocators


class BasePage():
    def go_to_login_page(self):
        link = self.browser.find_element(*BasePageLocators.LOGIN_LINK_INVALID)
        link.click()

    def should_be_login_link(self):
        assert self.is_element_present(*BasePageLocators.LOGIN_LINK), 'Login link is not presented'

```

Обратите внимание, что новые методы должны быть добавлены к уже имеющимся, иначе ваши тесты разучатся находить элементы
и т.п.

В классе MainPage у нас не осталось никаких методов, поэтому добавим туда заглушку:

```python
class MainPage(BasePage):
    def __init__(self, *args, **kwargs):
        super(MainPage, self).__init__(*args, **kwargs)

```

Добавляем в файл c тестами `test_product_page.py` новые тесты:

```python
def test_guest_should_see_login_link_on_product_page(browser):
    link = 'http://selenium1py.pythonanywhere.com/en-gb/catalogue/the-city-and-the-stars_95/'
    page = ProductPage(browser, link)
    page.open()
    page.should_be_login_link()

```

Добавьте самостоятельно второй тест `test_guest_can_go_to_login_page_from_product_page`.

Запустите тесты и убедитесь, что они выполняются положительно. Зафиксируйте изменения коммитом с осмысленным сообщением.

## Задание: наследование и отрицательные проверки

В файл `test_main_page.py` добавьте тест с названием `test_guest_cant_see_product_in_basket_opened_from_main_page`:

1. Гость открывает главную страницу
2. Переходит в корзину по кнопке в шапке сайта
3. Ожидаем, что в корзине нет товаров
4. Ожидаем, что есть текст о том что корзина пуста

В файл `test_product_page.py` добавьте тест с
названием `test_guest_cant_see_product_in_basket_opened_from_product_page`:

1. Гость открывает страницу товара
2. Переходит в корзину по кнопке в шапке
3. Ожидаем, что в корзине нет товаров
4. Ожидаем, что есть текст о том что корзина пуста

В классе BasePage реализуйте соответствующий метод для перехода в корзину.

Создайте файл `basket_page.py` и в нем класс BasketPage.
Реализуйте там необходимые проверки, в том числе негативную.
Убедитесь, что тесты проходят и зафиксируйте изменения в коммите.

## Группировка тестов: setup

Воспользуемся ООП для организации тестов. Pytest позволяет объединять тесты в тестовые наборы. Зачем это делать и почему
это удобно?

Во-первых, вы можете объединить тесты по смыслу, разделив функционал по фичам, компонентам или по какому-либо другому
признаку. Давайте тесты для MainPage необходимые для проверки логина выделим в отдельный тестовый набор в файле
`test_main_page.py` и пометим его меткой login_guest:

```python
@pytest.mark.login_guest
class TestLoginFromMainPage:
    # не забываем передать первым аргументом self                       
    def test_guest_can_go_to_login_page(self, browser):
        # реализация теста

    def test_guest_should_see_login_link(self, browser):
        # реализация теста

```

Запустите тестовый набор используя маркировку, необходимо добавить флаг `-m` и название метки. Обратите внимание, что
использована всего лишь одна метка, а запущено два теста.

Во-вторых, можно выделять общие функции для всего тестового набора, чтобы не заниматься дублированием кода. Эти функции
уже нам знакомы: setup - функция, которая выполняется до запуска теста и teardown - функция, которая запускается после
каждого теста, как правило в неё помещают методы очистки окружения или его восстановление после теста. Такие функции
реализуют с помощью фикстур. Важно обратить внимание на область использование фикстуры `scope="function"`, что будет
означать, что фикстура будет исполняться для каждой функции, и на параметр `autouse=True`, который говорит, что фикстура
будет использоваться без явного вызова.

Для обеспечения независимости от контента там, где мы взаимодействуем с товаром, создавать новый товар по API и
взаимодействовать с ним. Удаляя товар после выполнения тестового сценария. Наш интернет-магазин не поддерживает такой
опции, но важно понимать важность использования п группировки тестовы и выделения подготовительных и завершающих шагов.

Давайте посмотрим на пример реализации тестов в подобном случае:

```python
@pytest.mark.login
class TestLoginFromProductPage:
    @pytest.fixture(scope='function', autouse=True)
    def setup(self):
        self.product = ProductFactory(title='Created book')
        # создание по API
        self.link = self.product.link
        yield
        # после этого ключевого слова начинается teardown
        # выполнится после каждого теста в классе
        # удаляем те данные, которые мы создали 
        self.product.delete()

    def test_guest_can_go_to_login_page_from_product_page(self, browser):
        page = ProductPage(browser, self.link)
        # реализация теста

    def test_guest_should_see_login_link(self, browser):
        page = ProductPage(browser, self.link)
        # реализация теста

```

## Задание: группировка тестов и setup

Давайте попрактикуемся в написании сетапов для объединённых в группу тестов. Важно отметить, что этот пример
исключительно для учебных целей и практики для закрепления теоретических аспектов. В реальной разработке используются
API методы или база данных для этих целей.

Настала пора добавить тестовые сценарии не только для гостей нашего интернет-магазина, но и для зарегистрированных
пользователей.

1. В файле `test_product_page.py` создайте новый класс TestUserAddToBasketFromProductPage.
2. Скопируйте в него уже реализованные тесты test_guest_cant_see_success_message и test_guest_can_add_product_to_basket
   и переименуйте в них `guest` на `user`. Содержимое этих тестов можно не менять. Всё, что вам нужно будет сделать, -
   это добавить шаг регистрации.
3. Реализуйте в LoginPage метод `register_new_user(email: str, password: str)`, который принимает две строки и 
   регистрирует пользователя.
4. Добавьте в BasePage проверку того, что пользователь залогинен:

```python
def should_be_authorized_user(self):
    assert self.is_element_present(*BasePageLocators.USER_ICON), \
        'User icon is not presented, probably unauthorised user'

```

5. Добавьте локатор соответственно в BasePageLocators:

```python
USER_ICON = (By.CSS_SELECTOR, '.icon-user')

```

6. Добавьте в класс фикстуру setup. В этой функции нужно:

* открыть страницу регистрации;
* зарегистрировать нового пользователя;
* проверить, что пользователь залогинен.

Убедитесь, что тесты проходят и действительно регистрируют новых пользователей.

Зафиксируйте изменения с осмысленным сообщением в репозитории.
