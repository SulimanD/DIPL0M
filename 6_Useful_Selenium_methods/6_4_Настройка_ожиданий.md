# Настройка ожиданий

Разработчики усердно работали над созданием красивых и быстро загружаемых веб-страниц с плавными переходами между ними.
Это было достигнуто за счет использования подхода одностраничных приложений (SPA), когда сайт имеет только
одну страницу, а ее содержимое динамически обновляется с помощью JavaScript, который обменивается информацией с сервером
через REST API.

Хотя этот подход обеспечивает удобство работы с пользователем, он создает проблемы для тех, кто создает UI автотесты.
Непредсказуемое появление или исчезновение элементов на странице, непредсказуемое время рендеринга и
изменение текста в кнопках или сообщениях — вот некоторые особенности приложений SPA, которые необходимо учитывать при
автотестировании. Это один из самых сложных и запутанных аспектов разработки автотестов в Selenium (и других фреймворках
для E-2-E (end-to-end) тестов).

Мы рассмотрим эти распространенные проблемы и узнаем, как их преодолеть.

## Работа методов `get()` и `find_element()`

Резберем тест, проверяющий работу кнопки.

Тестовый сценарий:

1. Открыть страницу http://suninjuly.github.io/wait1.html
2. Нажать на кнопку "Verify"
3. Проверить, что появилась надпись "Verification was successful!"

Страница открывается с помощью метода `.get()`, после чего поиск нужной кнопки осуществляется с помощью одного из
методов `.find_element_by_()`.
Затем для нажатия на кнопку используется метод `.click()`. После этого идентифицируется новый элемент с
определенным текстом, и его текст проверяется на соответствие ожидаемому тексту.

Вот как выглядит код автотеста:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/wait1.html")

button = browser.find_element(By.ID, "verify")
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
```

Сначала попытайтесь выполнить тест в ручную, а затем перейдите к автотесту. При выполнении ручного теста вы успешно
завершите тест, но в случае автотеста он завершится ошибкой и сгенерирует сообщение `NoSuchElementException`
для элемента с id="verify". В чем может быть причина этой ошибки?

В Python команды выполняются синхронно, то есть выполняются строго последовательно. Это подразумевает, что пока команда
`get` не будет выполнена, поиск кнопки не начнется. Точно так же, пока кнопка не найдена, на нее нельзя нажать и так
далее.

Однако надежность теста не гарантируется, если веб-страница использует JavaScript (что весьма вероятно на современных
веб-сайтах). Метод `get` ожидает, пока браузер подтвердит загрузку страницы, после чего тест переходит к поиску кнопки.
Однако, если страница является интерактивной, браузер может считать страницу загруженной, в то время как скрипты,
загруженные браузером, продолжают выполняться. Скрипт может управлять внешним видом кнопки на странице и отображать ее с
задержкой, придавая ей плавный вид. В этом случае наш тест завершится ошибкой `NoSuchElementException`,
так как элемент с id="verify" не отображается на странице при выполнении команды
`button = browser.find_element(By.ID, "verify")`.
Эта страница имеет 1-секундную задержку перед появлением кнопки,
и метод `find_element()` попытается найти элемент только один раз, в случае неудачи завершив проверку.

## Фикс с помощью time.sleep()

Поскольку мы знаем о задержке появления кнопки, мы можем ввести паузу перед поиском элемента. Поскольку мы использовали
библиотеку `time` ранее, мы можем использовать ее и здесь.

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/wait1.html")

time.sleep(1)
button = browser.find_element(By.ID, "verify")
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
```

Текущее решение добавления фиксированной задержки перед поиском элемента может быть неэффективным при обработке
различных сценариев. Например, если элемент с сообщением тоже появляется с задержкой, или время задержки меняется при
появлении кнопки. Точно так же скорость Интернета на разных машинах может вызывать различия во временном интервале,
когда появляется кнопка. Хотя добавление задержки перед каждым действием может показаться решением, это непрактично, так
как может излишне увеличить время выполнения теста. С увеличением количества тестов эта проблема будет только
усугубляться.

## Фикс с помощью Selenium Waits (Implicit Waits)

Решение с time.sleep() плохое: оно не масштабируемое и трудно поддерживаемое.

Лучший способ справиться с ложными ошибками теста, вызванными асинхронным выполнением сценариев или задержками
сервера, — реализовать решение, которое ожидает появления определенного элемента на странице в течение заданного периода
времени (например, 5 секунд). Мы можем проверять наличие элемента каждые 500 миллисекунд, и как только элемент будет
найден, мы можем сразу перейти к следующему шагу теста. Таким образом, мы можем получить желаемый элемент как можно
скорее в лучшем случае или в течение 5 секунд в худшем случае.

Selenium WebDriver предоставляет особый подход к обработке этого ожидания, который позволяет нам установить ожидание во
время инициализации драйвера и применить его ко всем тестам. Это ожидание называется неявным ожиданием, поскольку нам не
нужно явно указывать его каждый раз, когда мы ищем элементы. Он будет автоматически применяться к каждой последующей
команде.

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
# говорим WebDriver искать каждый элемент в течение 5 секунд
browser.implicitly_wait(5)

browser.get("http://suninjuly.github.io/wait1.html")

button = browser.find_element(By.ID, "verify")
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
```

С неявным ожиданием, установленным во время инициализации драйвера, мы можем гарантировать, что наши тесты останутся
стабильными даже при незначительных задержках на веб-сайте. Для каждого экземпляра команды `find_element` WebDriver
будет ждать до 5 секунд, пока элемент появится на странице, прежде чем вызвать исключение `NoSuchElementException`.

# Фикс с помощью Explicit Waits (WebDriverWait и expected_conditions)

На предыдущем шаге мы решили проблему ожидания загрузки элементов на странице. Однако метод `find_element` только
проверяет наличие элемента на странице. Между тем, элемент может иметь другие атрибуты, которые могут быть важны для
наших тестов.

Рассмотрим пример с кнопкой, которая отправляет данные:

+ Кнопка может быть неактивной, то есть её нельзя кликнуть;
+ Кнопка может содержать текст, который меняется в зависимости от действий пользователя. Например, текст "Отправить"
  после нажатия кнопки поменяется на "Отправлено";
+ Кнопка может быть перекрыта каким-то другим элементом или быть невидимой.

Если кнопка неактивна в тот момент, когда мы хотим нажать на нее во время теста, WebDriver все равно будет имитировать
действие нажатия на кнопку, но данные отправляться не будут.

Попробуем запустить следующий тест:

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
# говорим WebDriver ждать все элементы в течение 5 секунд
browser.implicitly_wait(5)

browser.get("http://suninjuly.github.io/wait2.html")

button = browser.find_element(By.ID, "verify")
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
```

Мы видим, что WebDriver смог найти кнопку с id="verify" и кликнуть по ней, но тест упал на поиске элемента "
verify_message" с итоговым сообщением:

`no such element: Unable to locate element: {"method":"id","selector":"verify_message"}`

WebDriver быстро нашел и нажал кнопку, хотя она еще не была активна, что привело к провалу теста. Это распространенная
проблема на реальных сайтах, так как кнопки могут быть не активны при загрузке. На странице специально установлена
1-секундная задержка после ее загрузки перед активацией кнопки.

Для обеспечения надежности теста необходимо не только найти кнопку на странице, но и дождаться, когда кнопка станет
кликабельной. Явные ожидания используются в Selenium WebDriver для установки определенных ожиданий для элемента.
Реализация явных ожиданий предполагает использование инструментов WebDriverWait и `expected_conditions`.
Давайте улучшим наш тест:

```python
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium import webdriver

browser = webdriver.Chrome()

browser.get("http://suninjuly.github.io/wait2.html")

# говорим Selenium проверять в течение 5 секунд, пока кнопка не станет кликабельной
button = WebDriverWait(browser, 5).until(
    EC.element_to_be_clickable((By.ID, "verify")))
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text
```

`element_to_be_clickable` вернет элемент, когда он станет кликабельным, или вернет `False` в ином случае.

Обратите внимание, что в объекте WebDriverWait используется функция `until`, которая принимает условие ожидания,
элемент и значение, которое будет использоваться для поиска элемента.
Модуль `expect_conditions` имеет несколько
[других условий](https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html),
которые можно использовать для определения требуемых ожиданий.

Если мы захотим проверять, что кнопка становится неактивной после отправки данных, то можно задать негативное правило с
помощью метода `until_not`:

```python
# говорим Selenium проверять в течение 5 секунд пока кнопка станет неактивной
button = WebDriverWait(browser, 5).until_not(
    EC.element_to_be_clickable((By.ID, "verify")))
```

## Задание: ждем нужный текст на странице

Попробуем теперь написать программу, которая будет бронировать нам дом для отдыха по строго заданной цене. Более высокая
цена нас не устраивает, а по более низкой цене объект успеет забронировать кто-то другой.

В этой задаче вам нужно написать программу, которая будет выполнять следующий сценарий:

1. Открыть страницу http://suninjuly.github.io/explicit_wait2.html
2. Дождаться, когда цена дома уменьшится до $100 (ожидание нужно установить не меньше 12 секунд)
3. Нажать на кнопку "Book"
4. Решить уже известную нам математическую задачу (используйте ранее написанный код) и отправить решение

Чтобы определить момент, когда цена аренды уменьшится до $100, используйте метод `text_to_be_present_in_element` из
библиотеки `expected_conditions`.

Если все сделано правильно и быстро, то вы увидите окно с числом.
