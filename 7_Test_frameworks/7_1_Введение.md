# Тестирование web-приложений и тестовые фреймворки

Для начала нам необходимо познакомиться с распространенными тестовыми фреймворками unittest и PyTest.
Это необходимо, чтобы называть наши скрипты тестами. А главный атрибут теста - это сопоставление ожидаемого результата
фактическому.

## Автоматическое и ручное тестирование

Чтобы писать хорошие автотесты необходимо понимать различия, сильные и слабые стороны ручного и автоматического
тестирования.

| Критерий                                  | Ручное тестирование                                                           | Автоматическое тестирование                                                       |
|-------------------------------------------|-------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
| Тестовое покрытие                         | Ограниченное тестовое покрытие из-за нехватки времени и ресурсов              | Полное тестовое покрытие может быть достигнуто с помощью больших наборов тестов   |
| Скорость выполнения                       | Медленное выполнение и большая трудоемкость                                   | Более быстрое выполнение, экономия времени и усилий                               |
| Человеческие ошибки                       | Подвержены человеческим ошибкам                                               | Менее подвержены человеческим ошибкам                                             |
| Содержание                                | Сценарии ручного тестирования требуют большего обслуживания и поддержки       | Сценарии автоматизированного тестирования требуют меньше обслуживания и поддержки |
| Регрессионное тестирование                | Ручное регрессионное тестирование отнимает много времени и подвержено ошибкам | Автоматизированное регрессионное тестирование эффективно и надежно                |
| Начальная стоимость и настройка окружения | Низкие первоначальные затраты и время настройки                               | Высокая начальная стоимость и время настройки                                     |
| Гибкость                                  | Более гибкие с точки зрения модификации тест-кейсов                           | Менее гибкие с точки зрения модификации тест-кейсов                               |
| Требования к навыкам                      | Не требует специальных технических навыков                                    | Требуются специальные технические навыки                                          |
| Когда использовать                        | При тестировании небольших изолированных функций или новых приложений         | При тестировании больших сложных систем с повторяющимися тестовыми сценариями     |

### Ручное тестирование лучше использовать в следующих случаях:

+ Для исследовательского тестирования, когда тестирование основано на интуиции, творчестве и опыте, а не на заранее
  определенном наборе тест-кейсов.
+ Для тестирования удобства использования, когда основное внимание уделяется пользовательскому опыту и требуется
  обратная связь.
+ Для тестирования небольших изолированных функций или новых приложений, где тестовые наборы ограничены, а стоимость
  автоматизации высока.
+ Когда тестирование требует участия человека, например, тестирование пользовательского интерфейса или интуитивное (
  ad-hoc) тестирование.

### Лучше использовать автоматизированное тестирование в следующих случаях:

+ При тестировании больших и сложных систем с повторяющимися тест-кейсами.
+ Когда требуется регрессионное тестирование, чтобы убедиться, что новые изменения не нарушают существующую
  функциональность.
+ Когда требуется тестирование производительности или нагрузочное тестирование для имитации большого количества
  пользователей.
+ Когда требуется интеграционное тестирование, чтобы убедиться, что все компоненты системы работают без сбоев.
+ При тестировании требуется высокая степень точности и согласованности, например, проверка данных или тестирование
  безопасности.

## Юнит-тесты (модульные тесты) и интеграционные тесты

Интеграционные тесты и модульные тесты — это типы автоматических тестов, но они различаются по своему объему и
назначению.

Модульные тесты сосредоточены на тестировании отдельных единиц кода, таких как функции или методы, изолированно от
остальной системы. Цель модульных тестов — убедиться, что каждая сущность кода ведет себя ожидаемым образом в различных
условиях и что изменения в одной сущносте кода не нарушают работу других сущностей. Примеры модульных тестов могут
включать тестирование функции, вычисляющей квадратный корень из числа, или тестирование метода,
который складывает два числа.

Интеграционные тесты, с другой стороны, сосредоточены на проверке того, как различные блоки кода работают вместе, чтобы
сформировать полную систему. Целью интеграционных тестов является выявление проблем, которые могут возникнуть при
объединении различных единиц кода, таких как проблемы со связью между компонентами или с внешними системами. Примеры
интеграционных тестов могут включать тестирование сквозной функциональности веб-приложения или тестирование
взаимодействия базы данных с приложением.

Как правило, модульные тесты запускаются чаще и выполняются быстрее, чем интеграционные тесты, поскольку они тестируют
небольшие фрагменты кода изолированно. Однако интеграционные тесты важны для обеспечения правильной работы системы в
целом и обычно выполняются реже, чем модульные тесты.

Важно отметить, что граница между модульными тестами и интеграционными тестами иногда может быть нечеткой и что различие
между ними не всегда ясное. Некоторые тесты могут находиться где-то посередине, и в конечном итоге команда тестирования
должна определить, как лучше классифицировать и расставить приоритеты для своих тестов в зависимости от потребностей
проекта.

Подробнее про разные типы автотестов вы можете изучить самостоятельно. Вот хорошая
статья [Пирамида тестов на практике](https://habr.com/ru/articles/358950/).

## Структура теста

Основная структура тестирования как для модульных, так и UI автоматизированных тестов
может быть разбита на три части:

1. Test Setup: здесь подготавливаются среда и тестовые данные. В модульных тестах это может включать настройку фиктивных
   объектов(mocks) или заглушек для зависимостей, а в тестах пользовательского интерфейса — настройку веб-драйвера или
   эмулятора.
2. Test Execution: здесь выполняется фактическая тестовая логика. В модульных тестах это может включать вызов методов и
   проверку вывода, тогда как в тестах пользовательского интерфейса это может включать взаимодействие с элементами
   пользовательского интерфейса и проверку ожидаемого поведения.
3. Test Teardown: здесь выполняются любые действия по очистке. В модульных тестах это может включать сброс состояния
   любых фиктивных объектов, а в тестах пользовательского интерфейса это может включать закрытие веб-драйвера или
   эмулятора.

Несмотря на некоторые различия в деталях реализации модульных тестов и тестов пользовательского интерфейса, общая
структура тестов схожа. Оба типа тестов направлены на проверку функциональности приложения и обеспечение его правильного
поведения в различных сценариях.

Давайте обсудим, как именно можно производить проверки.

## Проверка ожидаемого результата

Один из способов проверить ожидаемый результат — использовать встроенный оператор `assert` в Python. Этот оператор
оценивает достоверность утверждений, позволяя вам убедиться, что ваш код работает должным образом. Если ваше утверждение
истинно, никаких дополнительных сообщений генерироваться не будет. Однако, если утверждение ложно, будет выдано
исключение `AssertionError` с текстом, которое вы можете указать после логической проверки.

Посмотрим как работает `assert` на примере:

```python
# Create a list of numbers
numbers = [1, 2, 3, 4, 5]

# Use the built-in sum() method to add up the numbers
total = sum(numbers)

# Assert that the total is 15
assert total == 15, "The sum of the numbers is incorrect"
```

В этом примере мы используем встроенный метод `sum()` для сложения чисел в списке чисел. Затем мы используем оператор
`assert`, чтобы проверить, что сумма чисел в списке равно 15, как мы ожидаем.
Если сумма не равна 15, оператор утверждения вызовет `AssertionError` и напечатает
сообщение `"The sum of the numbers is incorrect"`.
Вы можете изменить числа в списке, чтобы проверка оказалась не выполнена и посмотреть на работу оператора `assert` в
этом случае.

Обратите внимание на то, что когда ваших тестов станет огромное количество вы уже не будете помнить, что конкретно
проверяет каждый тест. И фраза "Сумма чисел некорректна" не проясняет суть проблемы и вам придется тратить время,
чтобы понять что конкретно пошло не так.

Давайте попытаемся уменьшить степень неопределенности нашего теста:

```python
# Create a list of numbers
numbers = [1, 2, 3, 4, 5]

# Use the built-in sum() method to add up the numbers
total = sum(numbers)

# Assert that the total is 15
expected_sum = 100500

assert total == expected_sum, \
    f"The sum of the list {numbers} is incorrect. " \
    f"Expected: {expected_sum}. Got: {total}."

```

## Задание: составные сообщения об ошибках

ля закрепления материала реализуйте проверку самостоятельно.

Вам дана функция test_input_text, которая принимает два значения: expected_result — ожидаемый результат, и
actual_result — фактический результат. Обратите внимание, input использовать не нужно!

Функция должна проверить совпадение значений с помощью оператора assert и, в случае несовпадения, предоставить
исчерпывающее сообщение об ошибке.

Маленький совет: попробуйте написать код и протестируйте его код на разных введенных
значениях, проверьте вывод вашей функции на разных парах. Обрабатывать ситуацию с пустым или невалидным вводом не нужно.

Sample Input 1: 8 11
Sample Output 1: expected 8, got 11

Sample Input 2: 11 11
Sample Output 2:

Sample Input 3: 11 15
Sample Output 3: expected 11, got 15

<details>
  <summary>Правильный ответ</summary>

```python
def test_input_text(expected_result, actual_result):
    assert expected_result == actual_result, f'expected {expected_result}, got {actual_result}'
```

</details>

## Задание: составные сообщения об ошибках и поиск подстроки

Вам дан шаблон для функции test_substring, которая принимает два значения: full_string и substring.

Функция должна проверить вхождение строки substring в строку full_string с помощью оператора assert и, в случае
несовпадения, предоставить исчерпывающее сообщение об ошибке.

Важно! Формат ошибки должен точно совпадать с приведенным в примере, чтобы его засчитала проверяющая система!

Маленький совет: попробуйте написать код и протестируйте его код на разных введенных
значениях, проверьте вывод вашей функции на разных парах. Обрабатывать ситуацию с пустым или невалидным вводом не нужно.

Sample Input 1: fulltext some_value
Sample Output 1: expected 'some_value' to be substring of 'fulltext'

Sample Input 2: 1 1
Sample Output 2:

Sample Input 3: some_text some
Sample Output 3:

<details>
  <summary>Правильный ответ</summary>

```python
def test_substring(full_string, substring):
    assert substring in full_string, f'expected \'{substring}\' to be substring of \'{full_string}\''
```

</details>

## Тестовые сценарии

Созданные тесты нужно сохранить в файле, чтобы его было удобно запускать и хранить в системе контроля версий. Давайте
создадим файл `test_list_sum.py` и напишем в нём следующий код:

```python
"""Making first test scripts."""


def test_sum_of_list_elements_equals_fifteen(input_list: list[int]) -> None:
    """Testing that sum of list elements is equal to 15."""
    total = sum(input_list)
    assert total == 15, \
    f"The sum of the list {input_list} is incorrect. " \
    f"Expected: 15. Got: {total}."


if __name__ == "__main__":
    """This method works if started from that module."""
    numbers = [1, 2, 3, 4, 5]
    test_sum_of_list_elements_equals_fifteen(numbers)
    print("All tests passed!")
```

Тест-кейс помещен в отдельную функцию, чтобы можно было независимо к нему обращаться.

В этом файле мы вызываем функцию `test_sum_of_list_elements_equals_fifteen()` и передаем ей в качестве аргумента
наш список. Функция выполняет тестовый сценарий. Если тесты прошли успешно, то мы увидим в терминале выполнение
команды `print("All tests passed!")`.

Запустите тест и посмотрите как он работает. Попробуйте изменить входные данные так, чтобы тест провалился.

Добавим в файл `test_list_sum.py` еще один тест и обратим внимание на поведение оператора `assert`: при провале любого
теста прекращается выполнение команд интерпретатором.

Добавим следующий код:

```python
"""Making first test scripts."""


def test_sum_of_list_elements_equals_fifteen(input_list: list[int]) -> None:
    """Test that sum of list elements is equal to 15."""
    total = sum(input_list)
    assert total == 15, \
    f"The sum of the list {input_list} is incorrect. " \
    f"Expected: 15. Got: {total}."


def test_number_is_greater_than_five(number: int) -> None:
    """Test that the number is greater than 5."""
    assert number > 5, \
    f"Number {number} is not greater than 5."


if __name__ == "__main__":
    """This method works if started from that module."""
    big_number = -191
    test_number_is_greater_than_five(big_number)
    numbers = [1, 2, 3, 4, 5]
    test_sum_of_list_elements_equals_fifteen(numbers)
    print("All tests passed!")

```

## Выбор test runner

В предыдущих шагах мы научились писать простые тесты и запускать их с помощью Python. Приведём здесь код тестов и
результаты запуска из предыдущего шага еще раз.

### test_list_sum.py

```python
"""Making first test scripts."""


def test_sum_of_list_elements_equals_fifteen(input_list: list[int]) -> None:
    """Test that sum of list elements is equal to 15."""
    total = sum(input_list)
    assert total == 15, \
    f"The sum of the list {input_list} is incorrect. " \
    f"Expected: 15. Got: {total}."


def test_number_is_greater_than_five(number: int) -> None:
    """Test that the number is greater than 5."""
    assert number > 5, \
    f"Number {number} is not greater than 5."


if __name__ == "__main__":
    """This method works if started from that module."""
    big_number = -191
    test_number_is_greater_than_five(big_number)
    numbers = [1, 2, 3, 4, 5]
    test_sum_of_list_elements_equals_fifteen(numbers)
    print("All tests passed!")

```

### Консоль

```shell
Traceback (most recent call last):
  File "C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum.py", line 21, in <module>
    test_number_is_greater_than_five(big_number)
  File "C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum.py", line 14, in test_number_is_greater_than_five
    assert number > 5, \
           ^^^^^^^^^^
AssertionError: Number -191 is not greater than 5.
```

### Рассмотрим минусы такого подхода к запуску автотестов:

+ По мере роста количества тестов становится сложно изолировать и запускать только необходимые наборы тестов.
+ Чтобы выполнить каждый тест, вы должны подготовить тестовые данные и среду независимо друг от друга. Например, если вы
  хотите открывать и закрывать браузер для каждого теста, логика работы браузера должна быть воспроизведена в коде
  каждого отдельного теста.
+ Если тест завершается ошибкой из-за ошибки AssertionError, последующие тесты выполняться не будут. Следовательно,
  любые потенциальные проблемы в этих тестах останутся неизвестными до тех пор, пока неудачный тест не будет устранен
  или пока каждый тест не будет выполнен вручную по отдельности.

Чтобы упростить процесс написания и выполнения тестов, разработчики используют специализированные фреймворки, известные
как средства выполнения тестов (test runners). Существует три основных тестовых фреймворка для Python:
unittest, PyTest и Nose. Заметным преимуществом обладает модуль unittest потому что он встроенный.
Между тем, PyTest и Nose предлагают расширенные функции,
которые превосходят возможности unittest. Мы сначала кратко рассмотрим использование unittest, а
затем углубимся в возможности PyTest, который позволяет использовать более простой тестовый код, чем unittest, и
обеспечивает гибкое выполнение тестов. Кроме того, PyTest имеет обширную библиотеку плагинов, которые могут решить
практически любую проблему, связанную с автоматическим тестированием.

## unittest

Тест-раннеры могут автоматически обнаруживать методы тестирования в указанных файлах при условии соблюдения
стандартных соглашений. Фундаментальное соглашение во всех средах тестирования заключается в том, что имя метода
тестирования должно начинаться со слова `test_`. Впоследствии может следовать любой текст для создания уникального имени
теста:

```python
def test_specific_meaningful_test_text():
    pass
```

Для unittest существуют собственные дополнительные правила:

+ Тесты обязательно должны находиться в специальном тестовом классе.
+ Вместо assert должны использоваться специальные assertion методы.

Давайте теперь изменим наши предыдущие тесты, чтобы их можно было запустить с помощью unittest. Для этого нам
понадобится выполнить следующие шаги:

1. Импортировать unittest в файл: `import unittest`
2. Создать класс, который должен наследоваться от класса TestCase: `class TestWithUnittest(unittest.TestCase):`
3. Превратить тестовые функции в методы, добавив ссылку на экземпляр класса `self` в качестве первого аргумента функции:
   `def test_sum_of_list_elements_equals_fifteen(self, input_list: list[int]) -> None:`
4. Изменить `assert` на `self.assertEqual()`
5. Заменить строку запуска программы на `unittest.main()`

```python
"""Making first test scripts."""
import unittest


class TestWithUnittest(unittest.TestCase):
    """Test class must be inherited from TestCase."""
    big_number = -191
    numbers = [1, 2, 3, 4, 5]

    def test_sum_of_list_elements_equals_fifteen(self) -> None:
        """Test that sum of list elements is equal to 15."""
        input_list = self.numbers
        total = sum(input_list)
        self.assertEqual(total, 15, \
                         f"The sum of the list {input_list} is incorrect. " \
                         f"Expected: 15. Got: {total}.")

    def test_number_is_greater_than_five(self) -> None:
        """Test that the number is greater than 5."""
        number = self.big_number
        self.assertTrue(number > 5, \
                        f"Number {number} is not greater than 5.")


if __name__ == "__main__":
    """This method works if started from that module."""
    unittest.main()
    print("All tests passed!")

```

После изменений запустим наш файл с тестами всё так же с помощью Python:

```shell
Ran 2 tests in 0.005s

FAILED (failures=1)

Failure
Traceback (most recent call last):
  File "C:\Users\Konuhov\Desktop\diplom\graduation-project-geek-brains\7_Test_frameworks\test_list_sum_unittest.py", line 21, in test_number_is_greater_than_five
    self.assertTrue(number > 5, \
AssertionError: False is not true : Number -191 is not greater than 5.

```

Теперь мы видим более подробную информацию о результатах запуска: было запущено два теста, один тест выполняется с
ошибкой. Место ошибки и пояснение к ней отображаются в логе.
